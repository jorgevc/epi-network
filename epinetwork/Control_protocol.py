#  control_protocol.py
#
#  Copyright 2018 Jorge Velazquez Castro
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#

import numpy as np
import random as rnd
import matplotlib.pyplot as plt

class controlProtocol:
    
	def __init__(self,params,P_network):
		"""
    	 La clase controlProtocol va a tener atributos
    	 y le asignamos valores a esos atributos, a su vez, esta clase se basa en crear datos, parametros y 
		 matrices para simular una pandemia en Simulation.py.
     	"""
		self.number_of_patches = len(params)
		self.observations = [[0]*5]*self.number_of_patches
		self.params = params
		self.P_network = P_network
		self.last_observation_time = None
		self.observation_interval = 1.
		self.control = [[0.,0.]]*self.number_of_patches
		self.TRh=[] #human Transmission index
		self.VR=[]  #Vulnerability index (human)
		self.TRv=[] #vector Transmission idex
		self.last_control_time = 0.
		self.control_interval = 1.

	def observe(self,y,t):
		"""
		Tomamos las observaciones y producimos indices con respecto al tiempo.
		"""
		self.observations=y
		self.last_observation_time=t
		self.calculate_indices(t)

	def observation_time(self,t):
		"""
		Colocamos un condicional donde, si en último valor del tiempo es exactamente "None" o,
		si el tiempo menos el tiempo final registrado el mayor al intervalo de observación, arrojara "True", 
		en caso de no cumplir esas condiciones, colocará "False"
		"""
		if(self.last_observation_time == None or (t - self.last_observation_time) > self.observation_interval):
			return True
		else:
			return False

	def recalculate_control(self):
		"""
		Veremos el indice de trasmición en un rango de -1,1; resultando en el máximo número de contagios,
		además de proveer una alternativa si TRh_max > 2.
		"""
		TRh = self.TRh[-1][1]
		TRh_max = max(TRh)
		max_transmition_patch = TRh.index(TRh_max)
		#if( TRh_max > 2.):
		self.control = [[0.,0.]] * self.number_of_patches
		self.control[max_transmition_patch] = [0.5,0.5]

	def calculate_control(self,t):
		"""
		En caso de la diferencia de tiempos sea mayor a 1, se le otorgará el valor
		de la función recalculate_control
		"""
		if(t - self.last_control_time > self.control_interval):
			self.recalculate_control()

	def get_control(self,i):
		"""
		Entrega el valor self.control
		"""
		return self.control[i]

	def calculate_indices(self,t):
		"""
		Definimos variables y creamos elementos que se agragaran a una lista
  		"""
		n=self.number_of_patches
		Sh=[]
		Ih=[]
		Rh=[]
		Sv=[]
		Iv=[]
		beta=[]
		gamma=[]
		mu=[]
		W=[]
		Nh=[]
		for i in range(n):
			Sh.append(self.observations[i][0])
			Ih.append(self.observations[i][1])
			Rh.append(self.observations[i][2])
			Sv.append(self.observations[i][3])
			Iv.append(self.observations[i][4])
			beta.append(self.params[i][0])
			gamma.append(self.params[i][1])
			mu.append(self.params[i][4])
			Nh.append(Sh[i] + Ih[i] + Rh[i])
   
		"""
		Creamos matrices ceros de nxn y para k en n, haremos un producto de matrices y para j en n veremos 
		un indice de infecciones secundarias producida por vectores infecciosos, a su vez, infecciones 
  		secundarias generadas por un individuo o por vectores, la vulnerabiñidad del parche j 
		y la tasa de transmisión.

  		"""
		Rv=np.zeros((n,n))
		Rh=np.zeros((n,n))
		p=self.P_network.matrix
		for k in range(n):
			W.append(np.dot(Nh,p[:,k]))
			for j in range(n):
				Rv[k,j]=(beta[j]*Sh[j]*p[j,k]*Iv[k])/(mu[k]*W[k]) #Secondary human infections of residentes from patch j produced by infected vectors in k (See ec. 20 of ref [1])
				Rh[j,k]=beta[k]*Ih[j]*p[j,k]*Sv[k]/(gamma[j]*W[k]) #Secondary vector cases in patch k caused by infected residents of patch i

		self.TRh.append((t,[(sum(np.dot(Rh,Rv)[i,:])) for i in range(n)])) #secondary infections generated by a single individual of patch i
		self.VR.append((t,[(sum(np.dot(Rh,Rv)[:,j])) for j in range(n)])) #vulnerability of patch j
		self.TRv.append((t, [sum(Rv[i,:]) for i in range(n)])) #vector transmission index (verificar)
		return self.TRh[-1][1]

	def set_observation_interval(self, dt):
		"""
  		Si control_interval es exactamente "None", entonces control_interval es igual a dt.
    	"""
		self.observation_interval = dt
		if(self.control_interval==None):
			self.control_interval = dt

	def set_control_interval(self, dt):
		"""
  		De manera similar si observation_interval es exactamente "None",
    	entonces observation_interval es igual a dt.
    	"""
		self.control_interval = dt
		if(self.observation_interval == None):
			self.observation_interval=dt

	def plot_TRindex(self, i):
		"""
  		Luego de tantos calculos, toca graficar, aqui los ejes serán el tiempo y tasa de transmisión 
		y ver como los contagios evolucionan con el tiempo.
    	"""
		plt.figure()
		plt.xlabel('Tiempo')
		plt.ylabel('TR_i')
		plt.plot(self.time,self.evolution[i,1,:])
		plt.show()


class noControl:
	"""
 	A grandes rasgos, creamos una "ruta de escape" en caso de que los parametros calculados
	no hayan sido tomados en cuenta.
  	"""
	def __init__(self,default = 0):
		self.default_control= [default,default]

	def observe(self,y,t):
		pass

	def observation_time(self,t):
		return False

	def calculate_control(self,t):
		pass

	def get_control(self,i):
		return self.default_control

class randomControl(controlProtocol):

	def recalculate_control(self):
		"""
  		Creamos unos un número random de parches para darle más versatilidad y fiabilidad a los calculos
		posteriores.
    	"""
		random_patch = rnd.randint(0,self.number_of_patches-1)
		self.control = [[0.,0.]] * self.number_of_patches
		self.control[random_patch] = [0.5,0.5]
